---
id: "oop_in_action"
title: "POO em a√ß√£o: Construindo os pilares do paradigma - Parte 1"
author: "Luan Roger"
date: 2024-01-12
draft: false
tags:
- "oop"
- "java"
- "abstraction"
- "encapsulation"
- "motion-canvas"
postType: "Learn"
description: "Vamos tentar uma abordagem diferente, ver os conceitos da POO por meio do ‚Äúm√£o na massa‚Äù, quebrando cada exemplo em partes, explicando cada uma delas e esclarecendo algumas decis√µes de design, juntamente com algumas anima√ß√µes simples. Este √© o primeiro post da s√©rie POO em a√ß√£o."
image: {
    src: "/images/posts/oop_in_action/oop_in_action.gif",
    alt: "Pixel Mood gif demo por Alwore",
    href: "https://alwore.itch.io/pixel-mood"
}
---
import BrandIcon from "../../components/BrandIcon.astro"
import DynamicImage from "../../components/DynamicImage.astro"

Esta ser√° uma s√©rie de posts que vou explicar todos os principais conceitos da POO (Programa√ß√£o Orientada a Objetos), mas s√≥ falar pode n√£o ser o bastante para voc√™ entender, ent√£o, vou usar alguns exemplos simples juntamente com aparatos visuais para ajudar na compreens√£o.
Espero que depois dessa s√©rie, voc√™ n√£o sinta mais medo de linguagens OO e ao inv√©s disso, use os conceitos a seu favor.

# T√≥picos abordados

Nesta s√©rie, vamos usar o Java com <BrandIcon brand="openjdk"/>JDK 21 para criar os exemplos pr√°ticos, escolhi o Java por ser amplamente usado em v√°rias √°reas al√©m de muitas faculdades ainda o usam para a disciplina de POO.

Para quem est√° come√ßando e n√£o teve muito contato com outras linguagens, pode acabar tendo dificuldade de ‚Äútraduzir‚Äù o que aprendeu em uma linguagem para outra, neste caso, levar os conceitos de POO para outra linguagem como <BrandIcon brand="csharp"/>[C#](https://learn.microsoft.com/pt-br/dotnet/csharp/tour-of-csharp), ent√£o, acho que o Java pode englobar o maior n√∫mero de pessoas.

Quero deixar claro que, se voc√™ est√° interessado em POO, ent√£o provavelmente j√° sabe os conceitos b√°sicos sobre linguagem de programa√ß√£o, como declara√ß√µes, fun√ß√µes, controle de fluxo e outros, se n√£o, ent√£o provavelmente vai se sentir mais perdido que o resto, sugiro aprender, na teoria e na pr√°tica, estes conceitos antes de continuar, al√©m disso, n√£o vou focar em ensinar a sintaxe e peculiaridades do Java, o intuito aqui √© ensinar POO.

Durante a s√©rie, vamos abordar os seguintes t√≥picos:

- ‚û°Ô∏è Parte 1 - Construindo os pilares do paradigma (Abstra√ß√£o e Encapsulamento).
- Parte 2 - Construindo os pilares do paradigma (Polimorfismo e Heran√ßa).
- Parte 3 - Rela√ß√µes entre objetos.
- Parte 4 - Fixando os conceitos da POO com mais pr√°tica.
- Parte 5 - Os princ√≠pios S.O.L.I.D
- Parte 6 - Aplicando [Padr√µes de projeto](https://pt.wikipedia.org/wiki/Padr%C3%A3o_de_projeto_de_software) (Design Pattern).
- Parte 7 - OO de forma inteligente com mais pr√°tica.
- Parte 8 - OO para a vida: Os conceitos de uma perspectiva diferente.

Esta ser√° uma s√©rie bem longa e pode ser que tenha algumas partes mais longas que outras, mas pe√ßo que se voc√™ quer realmente aprender este paradigma, ent√£o acompanhe a s√©rie at√© o final, pois ter√° bastantes detalhes que pode ser uma d√∫vida ou dificuldade que voc√™ esteja enfrentando.

Dentro destes t√≥picos v√£o estar alguns subt√≥picos que s√≥ ser√£o revelados quando o post for ao ar, n√£o ache que vamos falar somente do que est√° no t√≠tulo, at√© porque, o conte√∫do seria bastante superficial.

## O que √© POO?

Para quem est√° come√ßando, pode parecer que existe uma resposta certa, mas essa pergunta √© bem mais filos√≥fica do que parece. 
O intuito dessa s√©rie √© inteiramente educacional, passando uma vis√£o acad√™mica do assunto, vai servir para voc√™ acompanhar durante a cadeira de POO na faculdade por exemplo, mas para n√£o deixar voc√™ sem resposta, aqui vai uma defini√ß√£o bem superficial:

> POO √© uma forma de organizar seu c√≥digo, permitindo agrupar partes em comum, a fim de melhorar a manuten√ß√£o.

Isso vale tamb√©m para os pilares (vamos falar sobre eles mais a frente), j√° que definir eles tamb√©m n√£o √© simples, encapsulamento por exemplo, n√£o √© exclusivo da POO, se pegar a defini√ß√£o dele, pode ser aplicado em programa√ß√£o funcional e procedural.

Como disse, o intuito n√£o √© discutir a defini√ß√£o, √© passar o conte√∫do de forma clara, mas tenha isso em mente se quiser se aprofundar mais no assunto.

Sem mais delongas, vamos come√ßar com o conte√∫do.

# Um paradigma

Paradigma de uma linguagem de programa√ß√£o √© o que define suas principais caracter√≠sticas al√©m de ditar a forma que ela √© estruturada ou escrita no geral, algumas linguagens s√£o criadas pensando em seguir √† risca determinado paradigma, enquanto outras pode implementar v√°rios conceitos de outros paradigmas, que √© o que ocorre na maior parte das vezes, apenas algumas linguagens mais antigas implementam apenas um paradigma. 
Alguns outros paradigmas al√©m da POO:

| Paradigma  | Caracter√≠sticas                                                                                                                               | Exemplos de linguagem            |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------|
| Imperativo | Consiste em ‚Äúmandar‚Äù o que o computador deve executar exatamente; Mudan√ßa de estado por meio de declara√ß√£o ou chamada de fun√ß√µes (procedures) | Basic; C; C++; Fortran           |
| Funcional  | Mais pr√≥ximo de conceitos da matem√°tica determin√≠stica; suporte a lambdas; Recurs√£o; Evita mudan√ßa de estado                                  | Clojure; F#; Lisp; Scala; Elixir |
| Procedural | Muita influ√™ncia de programa√ß√£o imperativa; Modularidade por meio de procedures; Escopo que permite declara√ß√µes locais                        | C; Python; PHP; Lisp             |

Estes s√£o apenas alguns poucos exemplos de paradigmas que temos hoje, mas apesar de possu√≠rem conceitos diferentes, eles t√™m uma caracter√≠stica em comum: Todas influenciaram o OO, implementando algumas caracter√≠sticas de cada um desses paradigmas de alguma forma.

Linguagens que implementam OO pensa na programa√ß√£o como se fosse objetos colocados em c√≥digo por meio de abstra√ß√£o do mundo real (mais sobre isso nas pr√≥ximas se√ß√µes), estes objetos t√™m propriedades/atributos, ou seja caracter√≠sticas em forma de informa√ß√£o, al√©m de m√©todos, que s√£o a√ß√µes que um objeto pode executar.

Note que algumas linguagens implementam mais de um paradigma, como C++, Java, Python, etc. Isso significa que voc√™ n√£o √© obrigado a usar somente POO ou somente imperativo ou o que for, voc√™ pode usar os dois (ou mais) ou s√≥ um.

# Objetos ‚â† Classe

√â fundamental deixar isso claro, uma classe √© um molde para um objeto, um objeto √© o que chamamos de instancia de uma classe, a partir de uma classe criamos um novo objeto, geralmente fazemos isso com a palavra-chave `new`, mas isso depende da linguagem, isso ir√° gerar um objeto concreto que podemos guardar em uma vari√°vel por exemplo e usar seus atributos e m√©todos que definimos na classe.

<DynamicImage src="\images\posts\oop_in_action\class_object_light.gif" srcDark="\images\posts\oop_in_action\class_object_dark.gif"/>

## Objetos e classes

Uma classe √© um modelo para um ou mais objetos, partir de uma classe, iremos criar um novo objeto, para clarificar, em POO, n√£o √© comum falar que ‚Äúcriamos um objeto‚Äù √© mais certo dizer que ‚Äúinstanciamos um novo objeto‚Äù como falei no par√°grafo da se√ß√£o anterior. 
Para tornar mais claro, uma classe define atributos e comportamentos de um objeto, em um exemplo pr√°tico em Java:

```java
public class Livro {
    public String titulo;
    public String autor;
    public int anoPublicacao;
    public int numbPaginas;
}
```
*Livro.java*

Esta √© a forma de declarar uma classe em Java:

1. Modificador de acesso. No nosso casso, √© o `public` no come√ßo, vou falar seu proposito quando chegar em encapsulamento.
2. A palavra-chave `class`.
3. O nome da classe. No nosso caso, √© `Livro`.
4. O corpo da classe delimitado por `{` e `}`.
5. Dentro do corpo da classe, os membros que a comp√µem. No nosso caso, s√£o somente os **atributos t√≠tulo**, autor, etc. Mas pode haver mais tipos de membros como m√©todos e at√© mesmo [outras classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).

Com essa classe criada, podemos finalmente instanciar nosso objeto:
```java
import Models.Livro;

public class Main {
    public static void main(String[] args) {
        Livro livro = new Livro();
    }
}
```

A instancia√ß√£o ocorre em `Livro livro = new Livro();`, onde definimos uma vari√°vel do tipo da classe que queremos instanciar, pois √© isso que a vari√°vel vai conter um objeto do tipo `Livro`, para instanciar uma nova classe, usamos a palavra-chave `new`. 
Note que apenas instanciarmos um novo `Livro` mas n√£o fazemos nada com ele ainda, at√© aqui n√£o definimos quais ser√£o os valores das propriedades do livro.

Para atribuirmos valores aos atributos do livro, podemos acessar todas as propriedades de um por um e atribuir um valor a eles:
```java
Livro livro = new Livro();
livro.titulo = "Harry Potter e a Pedra Filosofal";
livro.autor = "J. K. Rowling";
livro.anoPublicacao = 1997;
livro.numbPaginas = 255;
```
1. O acesso a qualquer propriedade √© feita por meio do `.`, seguido do nome do atributo.

Mas dessa forma temos a chance de criar um objeto sem valores em suas propriedades, pois depende de n√≥s atribuirmos um de cada vez, e podemos acabar deixando um valor nulo sem querer. 
Para corrigir isso, podemos criar um construtor na nossa classe:
```java
public class Livro {
    public String titulo;
    public String autor;
    public int anoPublicacao;
    public int numbPaginas;

    public Livro(String titulo, String autor, int anoPublicacao, int numbPaginas) {
        this.titulo = titulo;
        this.autor = autor;
        this.anoPublicacao = anoPublicacao;
        this.numbPaginas = numbPaginas;
    }
}
```
Um construtor √© um m√©todo que possui o mesmo nome da classe e n√£o tem retorno na defini√ß√£o, mas o que s√£o m√©todos?

> üí° A palavra-chave `this` √© usada para referenciar a si mesmo, normalmente, sem o `this`, conseguimos acessar os m√©todos ou atributos da classe em que estamos, mas neste caso, os par√¢metros que recebemos no construtor tem o mesmo nome dos atributos da classe, ent√£o ele n√£o sabe de qual `titulo` estamos falando por exemplo, se √© o atributo da classe ou se √© o que estamos recebendo como par√¢metro no construtor. Isso √© chamado de shadowing e a palavra-chave `this` √© bem √∫til para resolver isso.

## M√©todos

De forma simples: M√©todos s√£o fun√ß√µes, s√≥ que em classes. A principal diferen√ßa est√° no come√ßo, o modificador de acesso. Vamos incrementar nosso exemplo com uma funcionalidade, um atributo para guardar se o livro j√° foi lido ou n√£o, assim:
```java
public class Livro {
    public String titulo;
    public String autor;
    public int anoPublicacao;
    public int numbPaginas;
    private boolean lido;

    public Livro(String titulo, String autor, int anoPublicacao, int numbPaginas) {
        this.titulo = titulo;
        this.autor = autor;
        this.anoPublicacao = anoPublicacao;
        this.numbPaginas = numbPaginas;
        lido = false;
    }

    public void ler() {
        lido = true;
    }

    public String jaFoiLido() {
        return lido ? "Sim" : "N√£o";
    }
}
```
Note que a propriedade `lido` √© `private` (vamos falar sobre isso na pr√≥xima se√ß√£o) e n√£o recebemos o valor dele pelo construtor, ao inv√©s disso, ele ser√° instanciado com esse valor, sempre como `false`, ou seja, um novo livro nunca ser√° criado como j√° lido.

Al√©m disso criamos tamb√©m dois novos m√©todos: `ler` e `jaFoiLido`, pois nossa propriedade `lido` √© privado, ent√£o vamos esclarecer logo sobre modificadores de acesso.

## Modificadores de acesso

Eles s√£o uma forma de garantir o n√≠vel de acesso que damos aos nossos componentes a componentes externos a ele.

No Java temos 4 n√≠veis de acesso:

| Modificador                | Classe | Pacote | Subclasse | Mundo |
|----------------------------|--------|--------|-----------|-------|
| `public`                   | ‚úîÔ∏è     | ‚úîÔ∏è     | ‚úîÔ∏è        | ‚úîÔ∏è    |
| `protected`                | ‚úîÔ∏è     | ‚úîÔ∏è     | ‚úîÔ∏è        | ‚ùå    |
| *sem modificador (padr√£o)* | ‚úîÔ∏è     | ‚úîÔ∏è     | ‚ùå        | ‚ùå    |
| `private`                  | ‚úîÔ∏è     | ‚ùå     | ‚ùå        | ‚ùå    |

*Fonte: [Controlling Access to Members of a Class](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)*

- Classe: Pode ser acessado na classe em que √© declarado.
- Pacote: Pode ser acessado no pacote em que √© declarado
- Subclasse: Pode ser acessado pelas classes filho de uma classe. Este est√° relacionado a heran√ßa.
- Mundo: Pode ser acessado de qualquer lugar da aplica√ß√£o, inclusive por pacotes externos a ele.

> üí° Vale ressaltar que o `private`, `protected`, n√£o pode ser usado em declara√ß√µes de alto n√≠vel, ou seja, apenas por membros de uma classe como atributos, m√©todos, *nested classes*, etc.

### Por que fazer `lido` privado?

Deixar a propriedade lido p√∫blica significa que quem vai usar a classe poder√° colocar o valor que quiser, e eu quero que depois de colocar o valor de `lido` para `true` ele n√£o possa mais voltar (ele n√£o pode ‚Äúdesler‚Äù o livro), para garantir isso, eu posso limitar o acesso ao atributo por meio do `private`, e a √∫nica forma dele ser acessado √© por meio de m√©todos, isso me d√° a possibilidade de moldar a forma de como a classe pode ser usada.

Al√©m do m√©todo `ler`, criei um outro m√©todo chamado `jaFoiLido`:
```java
public String jaFoiLido() {
    return lido ? "Sim" : "N√£o";
}
```
Simplesmente porque n√£o quero que quem for usar a classe, acesse a informa√ß√£o de forma mais humanizada, ao inv√©s de retornar `true` ou `false`, retorne Sim ou N√£o.

## Moldando o uso da classe

Voltando para o m√©todo `main`, onde nossa classe est√° sendo usada, vemos que mesmo depois de criarmos o construtor, ainda estamos usando a forma antiga (colocando os valores de um por um, para cada atributo), ent√£o vamos usar o construtor:
```java
public static void main(String[] args) {
    Livro livro = new Livro("Harry Potter e a Pedra Filosofal", "J. K. Rowling", 1997, 255);
}
```

Os par√™nteses que antes eram vazios (pois n√£o t√≠nhamos construtor) agora DEVEMOS passar todos os valores que recebemos no construtor, caso contr√°rio ele nem sequer ir√° compilar, ou seja, n√£o conseguimos instanciar a classe sem passar os valores que requisitamos.

Caso tente acessar o t√≠tulo do livro pela propriedade `titulo`, voc√™ ir√° conseguir sem problemas, j√° que o atributo √© p√∫blico na classe:
```java
Livro livro = new Livro("Harry Potter e a Pedra Filosofal", "J. K. Rowling", 1997, 255);

System.out.printf("Titulo do livro: %s", livro.titulo);
```
Mas isso significa que o atributo tamb√©m pode ser modificado, e eu n√£o quero que o livro mude depois que √© criado, isso vale tamb√©m para as outras propriedades como `autor`, `anoPublicacao` e `numbPaginas`. 
Para prevenir isso, vamos criar o que chamamos de Getter e Setter.

## Getter e Setter

Estes s√£o m√©todos que criamos para manter o controle de acesso dos atributos das nossas classes, m√©todos Get s√£o usados para recuperar valor de um atributo, enquanto o Set √© usado para atribuir valor ao atributo. 
A cria√ß√£o deles n√£o √© obrigat√≥ria para todo atributo, voc√™ os cria de acordo com a necessidade, inclusive, voc√™ pode criar apenas um Get, sem um Set, para um atributo, para assim garantir a imutabilidade.

Para controlar o acesso aos nossos atributos somente por meio dos Get e Set, vamos tornar todos os atributos privados:
```java
public class Livro {
    private String titulo;
    private String autor;
    private int anoPublicacao;
    private int numbPaginas;
    private boolean lido;

    public Livro(String titulo, String autor, int anoPublicacao, int numbPaginas) {
        this.titulo = titulo;
        this.autor = autor;
        this.anoPublicacao = anoPublicacao;
        this.numbPaginas = numbPaginas;
        lido = false;
    }

    public void ler() {
        lido = true;
    }
    public String jaFoiLido() {
        return lido ? "Sim" : "N√£o";
    }
}
```
Lembrando, eu n√£o quero que, depois de criado, o `titulo`, `autor`, `anoPublicacao` e `numbPaginas` n√£o sejam mais modificados, ent√£o para estes vamos criar apenas um Get:
```java
public String getTitulo() {
    return titulo;
}

public String getAutor() {
    return autor;
}

public int getAnoPublicacao() {
    return anoPublicacao;
}

public int getNumbPaginas() {
    return numbPaginas;
}
```
Os Get devem ser p√∫blicos para que eles possam ser acessados de fora da classe. 
√â uma pr√°tica comum os m√©todos Get terem o prefixo get depois o nome do atributo em CamelCase, √© importante ressaltar que o tipo de retorno da maioria dos m√©todos Get s√£o os memos de seus respectivos atributos, se n√£o s√£o, ent√£o antes de retornar performam algum tipo de convers√£o.

Para demonstrar o m√©todo Set vou criar um novo atributo na classe chamado `editora`, onde este vai ter um Get e um Set:

```diff
//...
private String autor;
+private String editora;
private int anoPublicacao;
//...
//...
public String getAutor() {
    return autor;
}

+public String getEditora() {
+    return editora;
+}

+public void setEditora(String editora) {
+    this.editora = editora;
+}

public int getAnoPublicacao() {
    return anoPublicacao;
}
///...
```
*Livro.java*

Da mesma forma do get, os m√©todos Set tamb√©m possuem o prefixo set seguido do nome do atributo em CamelCase, mas o Set n√£o tem retorno, pois a fun√ß√£o dele √© atribuir um novo valor a uma propriedade, este novo valor √© recebido no par√¢metro do m√©todo.

Agora nossa classe `Livro` est√° dessa forma:
```java
public class Livro {
    private String titulo;
    private String autor;
    private String editora;
    private int anoPublicacao;
    private int numbPaginas;
    private boolean lido;

    public Livro(String titulo, String autor, String editora, int anoPublicacao, int numbPaginas) {
        this.titulo = titulo;
        this.autor = autor;
        this.editora = editora;
        this.anoPublicacao = anoPublicacao;
        this.numbPaginas = numbPaginas;
        lido = false;
    }

    public String getTitulo() {
        return titulo;
    }

    public String getAutor() {
        return autor;
    }

    public String getEditora() {
        return editora;
    }

    public void setEditora(String editora) {
        this.editora = editora;
    }

    public int getAnoPublicacao() {
        return anoPublicacao;
    }

    public int getNumbPaginas() {
        return numbPaginas;
    }

    public void ler() {
        lido = true;
    }

    public String jaFoiLido() {
        return lido ? "Sim" : "N√£o";
    }
}
```

Perceba que os m√©todos `ler` e `jaFoiLido` s√£o uma esp√©cie de Get e Set, onde o `ler` √© o Set e o `jaFoiLido` √© o Get, mas como n√£o quero que o usu√°rio coloque qualquer valor no `lido`, ent√£o √© um Set que somente muda o valor para `true`, enquanto o `jaFoiLido`, performa um tipo convers√£o antes de retornar, isso n√£o deixa de ser um Get e Set.

Agora vamos atualizar nossa `main`:
```java
public class Main {
    public static void main(String[] args) {
        Livro livro = new Livro("Harry Potter e a Pedra Filosofal", "J. K. Rowling", "Bloomsbury", 1997, 255);

        String tituloMensagem = String.format("Titulo do livro: %s", livro.getTitulo());
        String autorMensagem = String.format("Autor do livro: %s", livro.getAutor());
        String editoraMensagem = String.format("Editora do livro: %s", livro.getEditora());
        String anoPublicacaoMensagem = String.format("Ano de publica√ß√£o do livro: %s", livro.getAnoPublicacao());
        String numbPaginasMensagem = String.format("N√∫mero de p√°ginas do livro: %s", livro.getNumbPaginas());

        System.out.println(tituloMensagem);
        System.out.println(autorMensagem);
        System.out.println(editoraMensagem);
        System.out.println(anoPublicacaoMensagem);
        System.out.println(numbPaginasMensagem);

        System.out.println("Modificando Editora...");
        livro.setEditora("Scholastic");

        editoraMensagem = String.format("Nova editora do livro: %s", livro.getEditora());
        System.out.printf(editoraMensagem);
    }
}
```
*Saida:*
```
Titulo do livro: Harry Potter e a Pedra Filosofal
Autor do livro: J. K. Rowling
Editora do livro: Bloomsbury
Ano de publica√ß√£o do livro: 1997
N√∫mero de p√°ginas do livro: 255
Modificando Editora...
Nova editora do livro: Scholastic
```

# Pilares da POO

A partir daqui vamos falar sobre a POO e que faz dela t√£o especial, come√ßando sobre o que molda a forma que programamos nas linguagens que implementam. 
No geral temos quatro pilares que devemos sempre ter em mente quando mexemos com POO: Abstra√ß√£o, encapsulamento, polimorfismo e heran√ßa. 
At√© aqui vimos apenas abstra√ß√£o e encapsulamento, ent√£o vou esclarecer apenas estes conceitos, no pr√≥ximo post, come√ßo falando sobre os outros dois e incrementamos este nosso exemplo que fizemos at√© aqui.

## Abstra√ß√£o

Esta diz respeito ao que voc√™ modela para dentro do seu software, pegar algo do mundo real e colocar no seu programa, no nosso exemplo abstra√≠mos um livro, criando a classe com seus atributos (propriedades) e a√ß√µes (m√©todos). 
Voc√™ pode ter notado que nem toda informa√ß√£o que tem em um livro tem na nossa classe, isso simplesmente porque n√£o precisamos delas, voc√™ pode ter se lembrado de ISBN, g√™nero, idioma, etc. Mas queria deixar o exemplo simples, ent√£o coloquei apenas o que achei necess√°rio.

Aplicar este conceito envolve muito do domino que est√° trabalhando, isso √©, a √°rea em que seu software est√° relacionado, ele representa os requisitos e desafios que seu software deve ter e solucionar, ent√£o, saber abstrair do mundo real para seu programa √© crucial para criar uma solu√ß√£o efetiva.

<DynamicImage src="\images\posts\oop_in_action\abstraction_light.gif" srcDark="\images\posts\oop_in_action\abstraction_dark.gif" />

## Encapsulamento

N√£o pense que encapsulando os membros do nosso programa vamos fazer dele mais seguro, encapsulamento √© sobre acesso e controle, ele d√° ao programador uma forma de moldar a forma de usar uma classe que criamos por meio de permiss√µes. 
Pode n√£o parecer grande coisa, mas isso √© bastante usado na cria√ß√£o de pacotes ou quando estamos trabalhando em equipe, onde devemos expor para eles apenas o que queremos que eles acessem, dessa forma, podemos dificultar o uso indevido da classe.

<DynamicImage src="\images\posts\oop_in_action\encapsulation_light.gif" srcDark="\images\posts\oop_in_action\encapsulation_dark.gif" />

# Continua√ß√£o

O exemplo que criamos √© bastante simples e pode n√£o ter muito do que tirar dele, mas vamos incrementar ele com mais conceitos nos pr√≥ximos posts, que caso tenha pulado, na se√ß√£o T√≥picos abordados tem os futuros assunto que vamos abordar.

Se quiser conferir o c√≥digo que ser√° escrito durante a s√©rie, aqui est√° o link:

[OOPInAction](https://github.com/LuanRoger/OOPInAction)

***Peace‚úåÔ∏è & Happy `new Year(2024)`üéÜ***