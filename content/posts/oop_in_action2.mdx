---
id: "oop_in_action2"
title: "POO em a√ß√£o: Construindo os pilares do paradigma - Parte 2"
author: rog
date: 2024-03-01
draft: false
tags: 
- "oop"
- "java"
- "inheritance"
- "polymorphism"
- "oop_in_action"
postType: "Learn"
description: "Vamos explorar os outros dois principais conceitos que constroem a POO, heran√ßa e polimorfismo s√£o dois conceitos que est√£o bastantes relacionados."
image: {
    src: "/images/posts/oop_in_action2/oop_in_action2.jpg",
    alt: "Everybody in florest - Chrono Trigger",
    href: "https://wallpaperflare.com/video-game-chrono-trigger-wallpaper-yntbj"
}
---
import DynamicImage from "../../components/DynamicImage.astro"

# Temas abordados:

- ‚úîÔ∏è Parte 1 - Construindo os pilares do paradigma (Abstra√ß√£o e Encapsulamento).
- ‚û°Ô∏è Parte 2 - Construindo os pilares do paradigma (Polimorfismo e Heran√ßa).
- Parte 3 - Rela√ß√µes entre objetos.
- Parte 4 - Fixando os conceitos da POO com mais pr√°tica.
- Parte 5 - Os princ√≠pios S.O.L.I.D
- Parte 6 - Aplicando [Padr√µes de projeto](https://pt.wikipedia.org/wiki/Padr%C3%A3o_de_projeto_de_software) (Design Pattern).
- Parte 7 - OO de forma inteligente com mais pr√°tica.
- Parte 8 - OO para a vida: Os conceitos de uma perspectiva diferente.

# Por que heran√ßa e polimorfismo est√£o juntos?

Decidi por heran√ßa e polimorfismo juntos porque eles s√£o complemento um do outro.
Ambos t√™m o mesmo prop√≥sito, reusar c√≥digo.

Mas n√£o pense que somente esses dois t√™m rela√ß√£o, a heran√ßa vai tornar a abstra√ß√£o e o encapsulamento mais complexos, ent√£o se voc√™ ainda n√£o viu o post anterior, sugiro que leia antes de continuar.

## Heran√ßa

O conceito da heran√ßa toma muito da biologia:
A heran√ßa permite que uma classe possa recusar ou modificar defini√ß√µes de outra classe. As defini√ß√µes que digo s√£o os membros da classe (atributos e m√©todos), mas n√£o s√≥ isso, porque voc√™ tamb√©m pode sobrescrever alguns deles, isso est√° mais para o conceito de polimorfismo, ent√£o primeiro, vamos explorar a heran√ßa.

### Superclasses e subclasses

Como vimos, heran√ßa reusa c√≥digo de outra classe, ent√£o precisamos ter no m√≠nimo duas classes, vamos criar nossas classes tamb√©m seguindo um pouco da biologia:
```java
public class Animal {
    private String nome;

    public Animal(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return nome;
    }
}
```
Como vimos anteriormente, podemos criar um objeto a partir dela d√° usando o `new`:

```java
Animal animal = new Animal("Cachorro");
```
Dessa forma, podemos ter quantos animais quiser, agora vamos criar o m√©todo `fazerBarulho`:

```java
public void fazerBarulho() {
	System.out.println("???");
}
```
Mas como vamos saber de qual animal estamos lidando?

> Podemos ler do atributo `nome` e criar um `if`/`else` ou `switch` para cada possibilidade.

Isso seria muito dif√≠cil de cobrir cada caso, al√©m de muito dif√≠cil de manter, al√©m disso, isso n√£o vai nos permitir de ter a√ß√µes espec√≠ficas para cada tipo de animal, por exemplo, se for uma ave, ter um m√©todo voar (sei que nem toda ave voa, mas vamos considerar que sim para simplificar nosso exemplo).

Perceba que ter um animal √© muito abstrato, mais do que o exemplo do `Livro` na parte anterior, precisamos de algo mais espec√≠fico, vamos usar a classe `Animal` para criar uma outra classe que seja mais espec√≠fica que ela, podemos come√ßar com a ave, ent√£o:
```java
public class Ave extends Animal {
    public Ave(String nome) {
        super(nome);
    }
}
```

Para herdar de uma outra classe usamos a palavra-chave `extends`, seguido do nome da classe que queremos herdar, neste caso estamos criando a classe `Ave` que herda de `Animal`.
Perceba que Ave j√° tem um construtor (m√©todo com o mesmo nome da classe e sem retorno declarado), nele recebemos uma `String nome` e logo passamos para `super`, mas o que √© este `super`?

Da mesma forma que o `this` faz refer√™ncia a nossa classe atual (`Ave`), o `super` faz refer√™ncia a nossa superclasse, a classe de quem somos subclasse. Agora:
- `Ave` √© subclasse de `Animal`.
- `Animal` √© superclasse de `Ave`.

Quando uma classe herda de outra, o que acontece com a subclasse:
- Declarar novos atributos que n√£o est√£o na superclasse;
- Criar novos m√©todos que n√£o fazem parte da superclasse;
- Membros n√£o privados da superclasse podem ser usados na subclasse;
- A subclasse pode chamar o construtor da superclasse.

A nossa classe `Animal` tem um construtor que possui par√¢metros, lembre-se que s√≥ podemos criar um objeto pelo construtor, mesmo que a nossa classe `Animal` esteja ‚Äúescondida‚Äù pela classe `Ave` ainda devemos chamar o seu construtor, at√© porque tudo que tem `Animal` faz parte de `Ave`, para chamar o construtor da nossa superclasse simplesmente usamos a palavra-chave `super` e passamos os par√¢metros nos par√™nteses, semelhante a instanciar, como s√≥ temos o par√¢metro `nome` em `Animal` ent√£o √© s√≥ isso que devemos passar.

Vale ressaltar que somente membros com modificadores de acesso mais permissivos que `private` podem ser acessados nas subclasses, ou seja, em `Animal`, n√£o podemos acessar diretamente o atributo `nome`, por hora, apenas `getNome` e `fazerBarulho`, o que n√£o √© um problema para n√≥s agora. Antes de continuar com a resolu√ß√£o do nosso problema do m√©todo `fazerBarulho`, vamos resolver um pequeno detalhe.

## Classes abstratas

Note que animal ainda pode ser instanciado, mas como havia dito anteriormente, esta classe √© bastante abstrata para ser usada sozinha, pois n√£o sabemos qual animal especificamente estamos lidando, ent√£o podemos fazer dela uma classe abstrata da seguinte forma:
```java
public abstract class Animal { /*...*/ }
```
Tornar a classe abstrata significa que ela n√£o pode mais ser instanciada, somente herdada, isso vai nos garantir que s√≥ existir√£o subclasses de `Animal` e nunca somente `Animal`.

### M√©todos abstratos

Para resolver nosso problema com o m√©todo `fazerBarulho`, podemos torn√°-lo abstrato tamb√©m, da seguinte forma:
```java
public abstract void fazerBarulho();
```

Isso significa que o m√©todo **DEVE** ser implementada nas subclasses que vir√£o, pois perceba que `fazerBarulho` n√£o tem mais implementa√ß√£o na classe `Animal`.
Isso vai nos permitir criar uma implementa√ß√£o espec√≠fica para os animais, assim cada um deles pode fazer um barulho diferente.

At√© agora, nossa classe animal est√° assim:
```java
public abstract class Animal {
    private String nome;

    public Animal(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return nome;
    }

    public abstract void fazerBarulho();
}
```

Agora vamos criar uma implementa√ß√£o para o m√©todo `fazerBarulho` na classe `Ave`:
```java
@Override
public void fazerBarulho() {
    System.out.println("Piu?");
}
```

> üí° Note a anota√ß√£o `@Override` no topo do m√©todo, isso indica ao compilador que o membro em quest√£o deve ser sobrescrever o membro declarado na superclasse.

Mas que ave exatamente estamos nos referindo, bem, a classe `Ave` ainda parece ser bastante abstrata, pois n√£o sabemos ainda exatamente com qual ave estamos lidando.
O que podemos fazer √© criar um `if`/`else` verificando o nome da ave, mas como disse, esta forma n√£o √© simples de manter e muito menos escal√°vel, ent√£o agora vamos criar uma implementa√ß√£o concreta da nossa classe `Ave`.

Mas antes, vamos marcar a classe Ave como abstrato e colocar algumas propriedades que somente aves possuem para diferenciar dos outros animais, al√©m disso, vamos remover a implementa√ß√£o de `fazerBarulho` da classe `Ave`, ent√£o nossa classe ficar√° assim no final:
```java
public abstract class Ave extends Animal {
    public boolean podeVoar;
    public Ave(String nome, boolean podeVoar) {
        super(nome);
        this.podeVoar = podeVoar;
    }
}
```
> Mas porque remove o m√©todo `fazerBarulho` se voc√™ disse que ele **DEVE** ser implementado?

A classe `Ave` agora √© uma classe abstrata, o que significa que ela foi criada para ser herdada e n√£o pode ser instanciada, os membros abstratos s√£o opcionalmente implementados em classes abstratas, mas devem ser implementadas em classes concretas (aquelas que ser√£o instanciadas).
Como nossa classe `Ave` agora √© abstrata, ent√£o n√£o precisamos sobrescrever os membros abstratos da nossa classe pai agora.

## Implanta√ß√£o concreta

Seguindo, vamos agora criar a nossa classe concreta que herda de `Ave`:

Come√ßando pelo construtor:
```java
public Galinha() {
    super("Galinha", false);
}
```

Note que o super faz refer√™ncia a classe `Ave`, ent√£o no construtor devemos chamar o `super` no nosso construtor tendo isso em mente.
Veja tamb√©m que, `Galinha` n√£o recebe par√¢metros, isso porque agora, podemos inferir todos os par√¢metros que a nossa superclasse recebe, e como n√£o criei nenhuma nova propriedade para `Galinha` ent√£o n√£o h√° nada que queiramos receber.
Vale ressaltar que nem todo case ser√° desta forma, isso aconteceu apenas por conta da forma que abstra√≠mos as nossas classes.

Agora para a implementa√ß√£o do m√©todo `fazerBarulho`:
```java
@Override
public void fazerBarulho() {
    System.out.println("Co Co");
}
```
Agora que temos finalmente uma implementa√ß√£o concreta da nossa classe e dos nossos membros.

A classe Galinha ficou da seguinte forma:
```java
public class Galinha extends Ave {
    public Galinha() {
        super("Galinha", false);
    }

    @Override
    public void fazerBarulho() {
        System.out.println("Co Co");
    }
}
```
Vamos instanciar nossa classe e chamar o m√©todo `fazerBarulho`:
```java
Galinha ave = new Galinha();
animal.fazerBarulho();
```
*Saida:*
```
Co Co
```

## Classes e tipos

> `Galinha` herdade de `Ave` que por sua vez herda de `Animal`, isso faz de uma instancia de `Galinha` uma instancia de `Animal` tamb√©m?

Sim, um objeto pode ter m√∫ltiplos tipos dependendo de sua hierarquia, isso significa que que um objeto do tipo `Galinha` tamb√©m √© do tipo `Ave` e `Animal`. Em um exemplo:

Podemos fazer:
```java
Animal animal = new Galinha();
```
pois `Galinha` herda de `Animal`. Mas temos uma ressalva:

Apesar de nossa vari√°vel guardar uma instancia de `Galinha`, o tipo dela √© `Animal`, o que significa que s√≥ teremos acesso aos membros do tipo `Animal`.
Isso significa que se quis√©ssemos acessar o `podeVoar`, n√£o vamos conseguir, pois esta √© uma propriedade de `Galinha`.

Isso √© √∫til quando queremos acessar apenas os membros de um tipo mais abstrato.
Vamos fazer um exemplo com o tipo `Ave`.

Primeiro vou criar uma nova classe que implementa `Ave`, seguindo a mesma forma de `Galinha`:
```java
public class Gaviao extends Ave {

    public Gaviao() {
        super("Gavi√£o", true);
    }

    @Override
    public void fazerBarulho() {
        System.out.println("AAA AAA");
    }
}
```
Agora vou criar um m√©todo na classe `Main`:
```java
private void consegueVoar(Ave ave) {
  String podeVoarMessage = String.format("%s pode voar", ave.getNome());
  String nPodeVoarMessage = String.format("%s n√£o pode voar", ave.getNome());

  if(ave.podeVoar) {
      System.out.println(podeVoarMessage);
      return;
  }

  System.out.println(nPodeVoarMessage);
}
```
Veja que este m√©todo recebe uma vari√°vel do tipo `Ave`, isso significa que podemos passar qualquer classe/tipo que herde de `Ave`, pois vamos usar apenas os membros deste tipo.
```java
public static void main(String[] args) {
    Ave galinha = new Galinha();
    Ave gaviao = new Gaviao();

    consegueVoar(galinha);
    consegueVoar(gaviao);
}
```
*Saida:*
```
Galinha n√£o pode voar
Gavi√£o pode voar
```

<DynamicImage src="/images/posts/oop_in_action2/classes_example-light.gif" srcDark="/images/posts/oop_in_action2/classes_example-dark.gif"/>

## E o polimorfismo?

O polimorfismo na OO, √© a forma que uma subclasse pode definir seu pr√≥prio comportamento e compartilhar alguma funcionalidade da sua superclasse.

Para voc√™ que ainda n√£o percebeu, foi exatamente o que fizemos nos exemplos acima, onde fica ainda mais claro o que fizemos no m√©todo `fazerBarulho`, onde a classe `Animal` define apenas a assinatura e suas subclasses devem criar sua pr√≥pria implementa√ß√£o deste m√©todo.

Veja que heran√ßa e polimorfismo est√£o t√£o relacionados que acabamos implementando os dois conceitos sem perceber, de forma natural, um acontece por causa do outro.

## Interfaces

Em alguns casos, n√£o necessitamos de uma nova classe para definir um comportamento para nossa classe, as interfaces s√£o uma forma de definir um ‚Äúcontrato‚Äù para as classes que implementam ela, uma interface dita como usamos uma classe especificamente, se assemelha bastante com o que fazemos com classes abstratas, inclusive, interfaces tamb√©m n√£o podem ser instanciadas, mas ao contr√°rio delas, as interfaces s√≥ devem conter assinaturas de m√©todos como membros, vari√°veis e campos n√£o s√£o permitidos.
Vamos come√ßar outro exemplo.

### Situa√ß√£o

Estou criando um sistema que pode ser integrado com outros, para tornar a tarefa de integra√ß√£o f√°cil para quem ir√° usar, vamos criar uma interface, como dito, isso ir√° firmar uma esp√©cie de contrato para com meu sistema e quem ir√° implementar fazer de forma correta.

Ent√£o vamos criar nossa interface:
```java
public interface SistemaUniversal {
    void verTodosUsuario();
    void criarUsuario(String nome);
    void deletarUsuario(String nome);
    void atualizarUsuario(String nomeAtual, String novoNome);
}
```
A interface `SistemaUniversal` define apenas as assinaturas dos m√©todos que ser√° usado tanto para quem vai implementar a interface quanto para quem vai usar.
Uma interface cont√©m apenas assinaturas dos m√©todos, mas nunca sua implementa√ß√£o, pois isso ser√° definido pela classe que ir√° implement√°-lo, coisa que iremos fazer agora:

Primeiro devemos definir que esta classe ir√° implementar a interface com a palavra-chave `implements`:

```java
public class Sistema1 implements SistemaUniversal { /*...*/ }
```

Agora, **DEVEMOS** implementar todos os m√©todos que definimos na interface:
```java
public class Sistema1 implements SistemaUniversal {
    private final ArrayList<String> usuarios;

    public Sistema1() {
        this.usuarios = new ArrayList<String>();
    }

    @Override
    public void verTodosUsuario() {
        for (final String usuario : usuarios) {
            System.out.println(usuario);
        }
    }

    @Override
    public void criarUsuario(String nome) {
        usuarios.add(nome);
    }

    @Override
    public void deletarUsuario(String nome) {
        usuarios.remove(nome);
    }

    @Override
    public void atualizarUsuario(String nomeAtual, String novoNome) {
        final int toUpdateIndex = usuarios.indexOf(nomeAtual);
        usuarios.remove(nomeAtual);
        usuarios.add(toUpdateIndex, novoNome);
    }
}
```

- `verTodosUsuario`: Exibe cada elemento da lista de usu√°rios.
- `criarUsuario`: Adiciona o valor que recebemos pelo par√¢metro na lista de usu√°rios.
- `deletarUsuario`: Remove o usu√°rio da lista pelo valor.
- `atualizarUsuario`: Recebe um par√¢metro contendo o nome atual do usu√°rio que ter√° seu nome atualizado e o novo nome, pega o index de onde este nome de usu√°rio se encontra, remove ele, e insere o novo nome no mesmo local que o antigo.

Agora temo um sistema que implementa a interface `SistemaUniversal`.

Assim como uma classe, uma interface tamb√©m pode ser um tipo, ent√£o da mesma forma que fizemos com `Ave`, vamos fazer com `SistemaUniversal`:
```java
public static void main(String[] args) {
    SistemaUniversal sistemaUniversal = new Sistema1();
    sistemaUniversal.criarUsuario("Roger");
    sistemaUniversal.verTodosUsuario();
}
```
*Saida:*
```
Roger
```
Da mesma forma do exemplo anterior, desta forma temos acesso somente ao que declaramos em `SistemaUniversal`, mas dependendo do real tipo que temos na vari√°vel (tipo durante o runtime) o comportamento pode mudar.

# Conclus√£o

Os dois assuntos, heran√ßa e polimorfismo est√£o t√£o relacionados que at√© mesmo o prop√≥sito dos dois s√£o os mesmos, reusar c√≥digo.
Antes de um exemplo mais elaborado, juntando todos estes conceitos b√°sicos, devemos dar uma r√°pida olhada sobre relacionamento entre objetos, que abordaremos no pr√≥ximo post.

Como sempre, o c√≥digo que vimos aqui est√° dispon√≠vel no reposit√≥rio abaixo:
- [Reposit√≥rio](https://github.com/LuanRoger/OOPInAction/tree/part2)

***Peace ‚úåÔ∏è***