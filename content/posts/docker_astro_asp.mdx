---
id: "docker_astro_asp"
title: "Introduzindo Docker na pr√°tica com Astro e ASP.NET"
author: rog
date: 2024-05-03
draft: false
tags: 
- "astro"
- "react"
- "docker"
- "aspnet"
- "typescript"
postType: "Learn"
description: "Considero que saber Docker √© t√£o crucial quanto saber Linux para quem √© desenvolvedor(a), ela pode participar de todas as etapas do desenvolvimento, do desenvolvimento at√© a produ√ß√£o, ent√£o vamos entender alguns conceitos importantes para voc√™ come√ßar com üêã Docker"
image: {
    "src": "/images/posts/docker_astro_asp/docker_astro_asp.png",
    "alt": "Legend Of Zelda: Link's Awakening landscape",
    "href": "https://wall.alphacoders.com/big.php?i=380464"
}
---
import BrandIcon from "../../components/BrandIcon.astro"

# Introdu√ß√£o

O <BrandIcon brand="docker"/> Docker j√° est√° no mercado a algum tempo, ele vem resolver os problemas que muitos de n√≥s desenvolvedores e DevOps vem enfrentando quando o assunto √© deploy, mas acabaram criando uma solu√ß√£o t√£o boa, que podemos usar at√© para desenvolver nossas aplica√ß√µes localmente.

Para voc√™ que est√° come√ßando na programa√ß√£o, Docker talvez n√£o fa√ßa muito sentido para voc√™ neste momento, mas quando come√ßar a criar servi√ßos que dependem de outros servi√ßos, ou se encontrar dizendo a bendita frase: ‚ÄúMas funciona na minha m√°quina‚Äù, ent√£o, saber√° que chegou a hora de aprender Docker.

# Porque Docker √© importante?

Para ter a real no√ß√£o do impacto do Docker no mercado, ele quem cunhou o termo ‚Äúconteineriza√ß√£o‚Äù (vou explicar o que significa mais a frente), v√°rios dos mais importantes servi√ßos de cloud hoje em dia, como <BrandIcon brand="amazonaws"/> AWS, <BrandIcon brand="googlecloud"/> Google Cloud, <BrandIcon brand="digitalocean"/> DigitalOcean, <BrandIcon brand="microsoftazure"/> Azure, etc. 
Suportam Docker e v√°rios destes servi√ßos oferecem produtos espec√≠ficos para deploy de cont√™ineres.

Isso tudo n√£o √© √† toa, a facilidade que ele traz para desenvolvermos nossas aplica√ß√µes principalmente, distribu√≠-las e escal√°-las, n√£o se compara ao que t√≠nhamos antes.

# Como Docker funciona?

Antes de prosseguir, vou falar de forma bastante simples para que o m√°ximo de pessoas entendam o que √© o Docker e como ele funciona, juntamente com alguns termos importantes que voc√™ vai ouvir e usar bastante daqui em diante.

## O que √© o Docker?

Docker em si pode ser visto de v√°rias formas, como uma ferramenta, uma plataforma ou at√© mesmo um simples utilit√°rio, pois como dito anteriormente, o Docker √© bastante vers√°til e flex√≠vel para ser usado em diferentes casos de uso, vou cobrir alguns deles mais a frente, mas vamos esclarecer o que ele √© primeiro.

O Docker ele √© separado em tr√™s camadas:

1. Cliente
2. Host
3. Registro

O principal componente √© o Host, nele √© onde fica as nossas imagens, containers (vou explicar eles mais a frente) e o mais importante: o Docker deamon.
Deamon √© um tipo de processo que fica em execu√ß√£o em segundo plano, isso significa que n√£o precisamos estar interagindo diretamente com ele para que funcione.

Este deamon √© o respons√°vel por gerenciar nossas, imagens, containers, volumes e outros. √â com ele que vamos rodar, construir e gerenciar nossos cont√™ineres, mas n√£o temos acesso direto com ele, para us√°-lo usamos o Cliente.

O cliente √© um CLI que o Docker disponibiliza para que possamos usar de tudo que o Docker tem a oferecer.

A camada de registro √© onde fica armazenados as imagens, que podem ser baixados para nossa instancia local do Docker, com ela, podemos criar uma imagem localmente e mand√°-la para o registro para que fique armazenado em outro local. 
O Docker Hub por exemplo, √© um registro p√∫blico, onde qualquer pessoa pode construir uma imagem e mandar para l√°, mas existem tamb√©m registros privados que voc√™ mesmo pode criar e colocar suas imagens, para que assim, elas posam ser acessadas facilmente e n√£o precise construi-la de novo.

Perceba que podemos ter tanto imagens locais, quanto em um registro, mas s√≥ podemos us√°-las (criar cont√™ineres a partir dela), se ela estiver local. Para comparar, o Docker Hub √© como o <BrandIcon brand="github"/> GitHub, mas ao inv√©s de gerenciar reposit√≥rios <BrandIcon brand="git"/> Git, ele gerenciar imagens de container Docker.

![Docker's layers](/images/posts/docker_astro_asp/docker_layers.png)
**Fonte:** [Docker overview | Docker Docs](https://docs.docker.com/get-started/overview)

## Termos

Para trabalharmos com Docker, usamos imagens, cont√™ineres, networks, volumes, etc. Mas o que tudo isso significa? 
Vamos come√ßar do mais simples e b√°sico: A imagem.

### Imagem

Uma imagem √© onde cont√©m um sistema operacional, sua aplica√ß√£o e todas as depend√™ncias que ela precisa para funcionar. 

Mas como colocamos um sistema operacional em uma imagem do Docker? 
Uma imagem pode ser criada a partir de outra imagem, como por exemplo, uma imagem de <BrandIcon brand="ubuntu"/> Ubuntu, que est√° p√∫blico no Docker Hub para usarmos, pode ser usada como base para criar nossa pr√≥pria imagem com nossa aplica√ß√£o. 
Para criar nossa pr√≥pria imagem, n√≥s precisamos criar um Dockerfile, neste arquivo, definimos tudo que nossa solu√ß√£o precisa para rodar, desde a imagem base at√© o comando para rodar ele, mais a frente, vou mostrar isso na pr√°tica.

### Dockerfile

Este √© um arquivo onde especificamos tudo que nossa imagem vai ter, ent√£o √© com ela que conseguimos criar nossa pr√≥pria imagem.

Nela √© onde especificamos a imagem base, onde especificar nossa aplica√ß√£o, como ela √© constru√≠da e executada, instalando tamb√©m suas depend√™ncias. 
Para gerar uma imagem a partir deste arquivo, √© necess√°rio construir a imagem com um comando no CLI do Docker, mais a frente, vou mostrar como isso funciona.

### Container

Um container √© uma inst√¢ncia que roda a partir de uma imagem, um container cont√©m o sistema de arquivo inteiro do SO que voc√™ escolheu para basear sua imagem. 
Ele tamb√©m inclui tudo o que voc√™ especificou, como a sua aplica√ß√£o e depend√™ncias.
Perceba que um container √© uma inst√¢ncia executada a partir da nossa imagem, portanto, podemos ter v√°rias inst√¢ncias da nossa aplica√ß√£o executando simultaneamente, isso √© muito bom para conseguirmos escalar solu√ß√µes, dividir carga, etc. 
Com isso, podemos facilmente levantar uma inst√¢ncia do banco de dados <BrandIcon brand="postgresql"/> PostgreSQL, sem nem precisar instal√°-lo em nossa m√°quina local, apenas com uma imagem do Docker, criamos quantos inst√¢ncias quisermos.

Uma inst√¢ncia pode ser criada, parada, movida e removida, al√©m disso, podemos fazer com que dois cont√™ineres se conectem por meio de networks virtuais criadas pelo Docker, dessa forma, conseguimos ter nossa aplica√ß√£o e suas depend√™ncias em um container e o banco de dados em outra.

# Aplicabilidades

Melhor que falar dos problemas que ele vem resolver, vou falar das aplicabilidades, j√° que √© o que torna o Docker uma ferramenta t√£o vers√°til. 
Aqui vou explicar um caso de uso para o Docker juntamente com um breve desenvolvimento sobre um problema, e no final, como o Docker pode ser usado para resolver este determinado problema.

## Distribui√ß√£o e deploy

Este pode ser o mais simples e b√°sico caso de uso para o Docker, e possivelmente, foi criado pensando neste prop√≥sito em espec√≠fico.

Quando criamos uma solu√ß√£o, seja um servi√ßo como uma API ou uma simples p√°gina est√°tica e queremos distribuir ela, temos a op√ß√£o de pagar por um VPS, estes VPSs geralmente veem apenas com um Linux ou Windows ‚Äúde f√°brica‚Äù, apenas com os programas padr√£o de cada sistema, ent√£o temos a √°rdua tarefa de instalar na m√£o, tudo que nossa aplica√ß√£o vai precisar para funcionar e ser usada por outros usu√°rios.

Com Docker podemos resolver isso de forma simples: Conteinizamos nossa aplica√ß√£o com tudo que ela precisa para rodar, colocamos no DockerHub (ou podemos fazer o build da imagem com o Dockerfile, caso n√£o queira distribuir ela), instalamos o Docker no nosso VPS, fazemos o pull da imagem e criamos um container com ela, pronto.

## Usar diferentes vers√µes de um software

Quando temos um sistema legado ou queremos testar nossa aplica√ß√£o em diferentes vers√µes de um SO, temos que manualmente gerenciar estas vers√µes, incluindo seu ferramental, como o <BrandIcon brand="nodedotjs"/> Node ou <BrandIcon brand="flutter"/> Flutter que tem seu pr√≥prio gerenciador de vers√µes, pois quando temos v√°rios projetos em que cada um usa uma vers√£o diferente das nossas ferramentas, temos que manter esta vers√£o em espec√≠fico para evitar problemas de compatibilidade at√© migrarmos para a vers√£o mais nova.

Isso pode ser f√°cil ou dif√≠cil dependendo da ferramenta que nossa aplica√ß√£o precisa para rodar, mas isso pode se tornar f√°cil para todo caso com Docker.

Um registro do Docker nos permite manter vers√µes anteriores a nossa atual, usando tags para nome√°-las. 
Assim, podemos facilmente fazer o pull da imagem daquela ferramenta que nossa aplica√ß√£o necessita, na exata mesma vers√£o em que ela foi criada por exemplo, podemos at√© usar vers√µes superiores ou inferiores, a fim de testar o comportamento.

## Teste

Por falar em testar, vamos entrar mais a fundo neste t√≥pico. Se voc√™ desenvolve sistemas a algum tempo, provavelmente, j√° teve que usar banco de dados, onde que muitas vezes, nossa aplica√ß√£o √© bastante dependente deste tipo de servi√ßo, o que pode tornar a configura√ß√£o do ambiente para teste de integra√ß√£o muito demorado, sem falar quando queremos rodar eles em um servi√ßo de CI/CD.

Docker pode facilitar este caso, voc√™ pode criar um compose, que √© um arquivo onde definimos um conjunto de servi√ßos (neste caso, cada servi√ßo √© um container), incluindo sua aplica√ß√£o, para que ela possa executar e executar os testes sem nenhum problema.

Outra alternativa √© usar [Testcontainers](https://testcontainers.com), que torna bem simples a configura√ß√£o inicial do ambiente e simplifica modifica√ß√µes futuras, como adi√ß√£o de novos servi√ßos, n√£o vou mostrar esta alternativa aqui para n√£o fugir muito da proposta central do post, fica a cita√ß√£o como tema de estudo.

# Pr√°tica

Como dito no t√≠tulo da postagem, vou mostrar todos estes conceitos na pr√°tica. O foco aqui √© o Docker, o projeto √© apenas para fins de demonstra√ß√£o.

## Em que consiste o projeto?

Uma aplica√ß√£o front-end <BrandIcon brand="astro"/> Astro simples, que consome de uma API feita com <BrandIcon brand="dotnet"/> ASP.NET, que por sua vez, usa um banco de dados PostgreSQL para armazenar informa√ß√µes de usu√°rios cadastrados. 
Este usu√°rio s√£o apenas informa√ß√µes brutas, n√£o cont√©m nenhuma forma de autentica√ß√£o.

### Front-end (Astro)

![Front-end screenshot](/images/posts/docker_astro_asp/astro_front.png)

No front-end, usei o Astro para gerar uma p√°gina est√°tica com <BrandIcon brand="html5"/> HTML e<BrandIcon brand="tailwindcss"/> TailwindCSS, para agilizar, usei o <BrandIcon brand="shadcnui"/> [shadcn-ui](https://ui.shadcn.com) para criar bot√µes e a tabela. 
Esta camada se comunica com a API por meio do <BrandIcon brand="axios"/> axios, fazendo requisi√ß√µes HTTP e tratando a resposta.

O font-end √© basicamente um CRUD de usu√°rio de forma bruta, sem tratamento, pois queria deixar o mais simples poss√≠vel, como havia dito, o intuito n√£o √© mostrar o projeto em si, mas como podemos usar ele com o Docker.

### Back-end (ASP.NET)

A tecnologia aqui foi muito de gosto, ent√£o use a tecnologia que preferir. 
√â uma simples API Web que recebe requisi√ß√µes do front, como a requisi√ß√£o de cadastro, leitura, atualiza√ß√£o, etc. A requisi√ß√£o ser√° tratada propriamente, e ent√£o, atualizar a estado do banco de dados PostgreSQL conforme a requisi√ß√£o.

> Usei este projeto para aprender a aplicar pela primeira vez a Clean Architecture, e sinto que ficou bastante interessante, recomendo dar uma olhada no reposit√≥rio, o link para ele vai estar no final do post.

# Conteinerizar a aplica√ß√£o

A partir daqui voc√™ deve ter o Docker instalado e funcionando, n√£o vou mostrar isso aqui, pois a documenta√ß√£o cobre isso de forma bastante clara, caso n√£o tenha ele instalado, acesse a p√°gina de download e instale, depois volte e continue aqui.

Caso queira verificar se est√° tudo funcionando, apenas rode este comando no terminal:

```bash
docker ps
```

Este comando ir√° mostrar todos os cont√™ineres em execu√ß√£o no momento, se o Docker n√£o estiver funcionando, um erro vai aparecer.

Como dito anteriormente nos termos, para conseguirmos criar uma imagem com nossa aplica√ß√£o, devemos criar um Dockerfile, o ideal √© que criaremos ele na raiz do projeto que vamos conteinerizar, no meu caso, minha estrutura est√° assim:

```
.
‚îú‚îÄ‚îÄ ./client
‚îî‚îÄ‚îÄ ./Server
```

O `client` (front-end) e o `Server` (back-end) s√£o tratados como aplica√ß√µes diferentes, ent√£o ser√° um Dockerfile pra cada, vou come√ßar pelo front-end.

Antes de continuar, saiba o que sua aplica√ß√£o precisa para ser executada, pois muitas vezes instalamos as ferramentas, mas n√£o lembramos como realmente fizemos isso, ent√£o tenha em mente este passo-a-passo, j√° que n√≥s vamos replic√°-lo mais √† frente.

Meu front-end √© um site est√°tico, ent√£o precisamos de um servidor HTTP para receber as requisi√ß√µes, aqui vou usar o <BrandIcon brand="nginx"/> NGINX. Al√©m disso, vou precisar tamb√©m do <BrandIcon brand="npm"/> NPM e do Git para fazer o build do meu site com Astro.

Na raiz do diret√≥rio `client` vou criar um arquivo chamado "Dockerfile" (sem extens√£o), com o seguinte conte√∫do:

```dockerfile
FROM nginx:stable-alpine as base
RUN apk add --no-cache nodejs npm git
EXPOSE 80

FROM base as build
WORKDIR /build
COPY . /build/
RUN npm install
RUN npm run build

FROM build as release
COPY --from=build /build/dist /usr/share/nginx/html
```

O Dockerfile funciona com instru√ß√µes e argumentos, a primeira palavra √© sempre a instru√ß√£o e o que vem depois s√£o os argumentos. Vamos falar sobre cada um deles:

- `FROM`: Define uma nova etapa de constru√ß√£o usando uma imagem como base. Neste caso, estou usando uma imagem com o sistema operacional <BrandIcon brand="alpinelinux"/> Alpine com o NGINX j√° configurado.
- `RUN`: Executa um comando e cria uma nova camada para ser usada nos pr√≥ximos passos do Dockerfile. Neste caso, o ``RUN`` aparece algumas vezes, isso porque ele executa comandos no terminal, ent√£o uso ele para instalar as depend√™ncias e construir a aplica√ß√£o
- `EXPOSE`: Faz com que o container escute nesta determinada porta na network em que est√°, como o NGINX exp√µe a porta 80 ent√£o fa√ßo com que o container possa receber requisi√ß√µes desta porta.
- `WORKDIR`: Defini o local atual de execu√ß√£o dos comandos. Ent√£o todo comando `RUN` por exemplo, ser√° executado neste diret√≥rio.
- `COPY`: Copia arquivos e diret√≥rios de fora do container para dentro. Isso √© bastante importante, pois √© com ela que copiamos nosso projeto para dentro do container para ser constru√≠do e executado. Neste caso, estou copiando tudo do meu diret√≥rio atual de fora do container, para o ``/build/`` dentro do container.

Estes n√£o s√£o as √∫nicas instru√ß√µes que um Dockerfile pode conter, mas aqui est√£o os mais importantes. Agora vamos esclarecer algumas peculiaridades:

- Uma imagem √© criada a partir de outra imagem com a instru√ß√£o `FROM`, uma imagem √© referenciada da seguinte forma: nome:tag. Aqui estamos usando a imagem `nginx` com a tag `stable-alpine`.
- Etapas e camadas s√£o bem importantes, o Docker faz cache delas para que possa ser usada novamente em um *build* local futuro
- `as` √© uma palavra-chave que podemos usar para definir o nome da etapa em que estamos para que possamos usar ela em outras camadas
- Na segunda etapa, usamos a camada anterior (`base`) como base para esta nova camada (`build`).
- Da mesma forma na √∫ltima instru√ß√£o `COPY`, usamos a *flag* `--from` para especificar de onde queremos copiar, estamos copiando o que foi constru√≠do em `/build/dist` para `/usr/share/nginx/html`, que √© o local onde colocamos p√°ginas est√°ticas para que o NGINX as entregue quando requisitamos.

Agora que sabemos como um Dockerfile funciona, vamos criar um que requer uma configura√ß√£o mais bem pensada. 
Como j√° havia dito, o back-end que vamos Conteinerizar foi criado em ASP.NET usando .NET, ent√£o devemos reproduzir tudo que fazemos normalmente para rodar este tipo de aplica√ß√£o, mas agora, por meio de instru√ß√µes no Dockerfile.

Da mesma forma que fiz anteriormente, vou mostrar o resultado final e explicar depois.

```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Server.csproj", "./"]
RUN dotnet restore "Server.csproj"
COPY . .
WORKDIR "/src/"
RUN dotnet build "Server.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "Server.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Server.dll"]
```

Come√ßamos definindo nossa primeira etapa chamada ‚Äúbase‚Äù usando a imagem de runtime do .NET 8 disponibilizada pela pr√≥pria Microsoft no seu reposit√≥rio de Docker. 
Perceba que a etapa seguinte usamos outra imagem, a do SDK do .NET 8, isso porque precisamos compilar nossa aplica√ß√£o antes de rodar, dessa forma n√£o ficamos dependentes de um build local.

Temos algumas instru√ß√µes novas, que n√£o apareceram no Dockerfile anterior:

- `ARG`: Define uma vari√°vel no Dockerfile, ela pode ser alterada na hora de constru√ß√£o da imagem usando este Dockerfile. Neste caso, estou usando para definir qual configura√ß√£o estou usando para construir minha aplica√ß√£o.
- `ENTRYPOINT`: Especifica qual execut√°vel o container ir√° rodar ao ser iniciado. Neste caso, uso o comando do CLI do .NET para executar a *dll* que foi gerado pelo comando `dotnet publish`.

> Mas por que n√£o usamos a instru√ß√£o `ENTRYPOINT` no exemplo anterior?

Pois como o NGINX √© um deamon que √© iniciado juntamente com o container, n√£o precisamos inici√°-lo, ent√£o, apenas colocamos os arquivos do nosso site para que ele possa servir.

Perceba que a nossa primeira etapa (‚Äùbase‚Äù) √© usada apenas pela √∫ltima etapa (‚Äùfinal‚Äù), pois a primeira etapa usa como base o runtime (o que √© preciso para rodar a aplica√ß√£o), mas n√£o tinha a ela constru√≠da, ent√£o as outras etapas entre ela e a etapa final, uso como base a imagem com o SDK do .NET 8 (que √© necess√°rio para construir a aplica√ß√£o). 
Assim, pego apenas o resultado do build, da imagem anterior para a final com a flag --from=publish.

# Criar as imagens

Agora que temos os dois Dockerfile para as duas partes da nossa aplica√ß√£o, vamos partir para a cria√ß√£o da imagem de Docker usando-as.

A partir daqui, se voc√™ n√£o tem o Docker instalado, ser√° necess√°rio instal√°-lo e deixar ele funcionando, pois como havia dito, ele √© um processo que fica rodando em segundo plano. Vamos usar a CLI dele para construir nossas imagens, para saber se o Docker est√° instalado, rode este comando no terminal.

```bash
docker --version
```

```
Docker version 26.0.0
```
**Saida**

> Se aparecer algum erro no seu, verifique se ele est√° de fato rodando.

Agora que sabemos que est√° tudo funcionando, vamos criar primeiro a imagem da nossa aplica√ß√£o cliente. Ent√£o vamos para a pasta onde o Dockerfile est√° localizado (a raiz da nossa aplica√ß√£o cliente) e executar o comando de build:

```bash
docker build -t luanroger/astro-client:1.0 .
```

O comando `docker build` √© usado para criarmos o uma imagem a partir de um Dockerfile, em seguida, passamos a flag `-t` para definir a tag da nossa imagem, o ponto no final indica o contexto do build, ou seja, onde ele vai considerar como raiz, j√° que no Dockerfile est√° na raiz da nossa aplica√ß√£o, ent√£o ele j√° ir√° identificar a exist√™ncia do arquivo neste contexto.

Se voc√™ configurou tudo certo no seu Dockerfile, ele vai ter criado a image, para visualizar as imagens que voc√™ tem, use o comando:

```bash
docker images
```

Ele vai listar as suas imagens, tanto as que voc√™ criou, quanto as que voc√™ fez o pull de reposit√≥rios do Docker, juntamente com suas respectivas tags e ID, tamanho da imagem, etc. Agora, antes de rod√°-las, vamos criar a imagem do nosso back-end, indo para a raiz dele e executando o mesmo comando, ele vai criar a imagem do ‚ÄúServer‚Äù, mas precisamos mudar apenas a tag, pois n√£o pode ter tags repetidas:

```bash
docker build -t luanroger/dotnet-server:1.0 .
```

Pronto. 
Agora temos as duas imagens que precisamos para finalmente rodas nossos cont√™ineres. 
Lembre-se que se quiser ver suas imagens, use o comando citado anteriormente.

# Criando os cont√™ineres

Antes de inici√°-los devemos fazer com que eles conversem entre si, pois por padr√£o, o Docker cria uma rede virtual para cada container, n√£o sendo poss√≠vel que ele converse com o mundo externo, mas n√≥s conseguimos acess√°-lo de fora. Mas devemos resolver este problema primeiro, j√° que nosso front-end n√£o vai funcionar direito sem nosso back-end.

## Criando redes no Docker

Para que dois cont√™ineres ‚Äúconversem‚Äù, eles devem estar na mesma rede do Docker, elas devem ser criadas antes de criarmos os cont√™ineres, j√° que eles s√£o criados com as redes j√° especificadas, ent√£o para criar as redes, usamos o seguinte comando:

```bash
docker network create -d bridge fullstack
```

`docker network` √© usado para gerenciar redes do Docker, em seguidas usamos o `create` para dizer que vamos criar uma nova rede, depois especificamos o driver, que neste casso, usamos o bridge, mas o Docker tem v√°rios outros drivers, se quiser saber mais sobre eles, [consulte a documenta√ß√£o](https://docs.docker.com/network/drivers). 
Por √∫ltimo, definimos o nome da rede, pronto, para ver as redes que temos criadas, usamos o comando:

```bash
docker network ls
```

Ele vai listar todas as redes, juntamente com seus drivers. 
Antes de prosseguir, vamos esclarecer uma d√∫vida que voc√™ provavelmente est√° tendo.

> J√° que minha aplica√ß√£o vai rodar em uma rede virtual, devo me preocupar com as portas que minha aplica√ß√£o usa para se conectar com outros servi√ßos.

E a resposta √© n√£o, a porta que sua aplica√ß√£o vai subir √© a mesma que voc√™ tenha configurado, o que vai mudar √© o host, pois vamos nos conectar em um host ‚Äúexterno‚Äù, ou seja, n√£o ser√° mais o localhost, o novo host que sua aplica√ß√£o vai se conectar ser√° o nome do container, assim, se voc√™ criar um container chamado ‚Äúapi‚Äù, ent√£o, o host que seu front-end vai se conectar vai ser `http://api:<porta>`, isso vai ficar mais claro quando criarmos os cont√™ineres.

# Subindo os cont√™ineres

Agora que temos tudo que precisamos para, finalmente, executar os cont√™ineres, vamos come√ßar criando o cont√™iner para o front-end usando a imagem `luanroger/astro-client` que criamos antes, para isso, vamos utilizar o seguinte comando:

```bash
docker run --name client -p 8080:80 -d --network fullstack luanroger/astro-client:1.0
```

`docker run` √© o comando do CLI do Docker que usamos para criar e rodar um container, em seguida, usamos a flag `-‚Äîname` para definir um nome para ele, agora com o `-p` especificamos a porta externa ao container (porta do host) que ser√° mapeada para uma porta dentro do container (host:container), neste caso, mapeamos a porta 8080 do meu computador para a porta 80 do container, j√° que minha aplica√ß√£o est√° rodando na porta 80.

Por fim, especificamos a rede virtual em que nosso container vai rodar com a flag `-‚Äînetwork`, que neste caso, √© a rede fullstack que criamos anteriormente, depois, passamos o nome da imagem que n√≥s criamos: fullstack `luanroger/astro-client:1.0`, a tag n√£o √© obrigat√≥ria, se voc√™ n√£o colocar, o Docker vai assumir o valor da tag como latest.

Mas e o `-d`? Esta √© uma flag para dizer ao Docker que queremos rodar o container em modo detached, ou seja, ele n√£o vai prender o terminal para exibir os logs da nossa aplica√ß√£o.

A partir daqui voc√™ j√° pode acessar seu localhost na porta 8080, que j√° vai conseguir ver o seu site, mas ele n√£o est√° conectado em nenhum back-end ainda, pois n√£o rodamos ele, vamos corrigir isso agora.

Vamos executar o container do back-end da mesma que o front-end, mas mudando apenas a parta que vamos expor e a imagem, desta forma:

```bash
docker run --name server -p 5000:8080 -d --network fullstack luanroger/dotnet-server:1.0
```

Perceba que mudei apenas a flag `-p` para a minha porta 5000 para a 8080 do container, que √© a porta em que minha API est√° rodando.

Minha API depende de um banco de dados PostgreSQL para funcionar, coisa que com o Docker podemos resolver tamb√©m, como isso vai fugir muito do escopo do artigo, vou mostrar um r√°pido passo-a-passo para subir um PostgresSQL usando o Docker:

## Subindo um PostgreSQL

Para subir um container, precisamos da imagem, mas a imagem de PostgreSQL n√£o precisamos criar por n√≥s mesmos, no Docker Hub (reposit√≥rio de imagens oficial do Docker) tem dispon√≠vel para apenas fazermos o pull, ent√£o:

1. Fazer o pull da imagem de PostgreSQL

```bash
docker pull postgres
```

2. Executar o container com a imagem

```bash
docker run --name db -p 5432:5432 -d --network fullstack -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin postgres
```

O meu back-end j√° est√° configurado para conectar com o front-end, como o Docker cria uma rede virtual, com a network que criamos anteriormente, ent√£o, todos os cont√™ineres nesta network tem um host pr√≥prio, onde o nome do host √© o nome do container. Ent√£o para meu backend se conectar ao PostgreSQL, uso o host db para se conectar.

## Subindo o cliente

Da mesma forma que fizemos o server, vamos fazer com o cliente:

```bash
docker run --name client -p 8080:80 -d --network fullstack luanroger/astro-client:1.0
```

Como o NGINX levanta meu servi√ßo na porta 80, vou mapear ela para conseguir acessar a partir da minha por 8080. Da mesma forma que fizemos para conectar o back-end no banco de dados, vamos fazer pro front-end conectar no back-end, configurando uma vari√°vel de ambiente chamada `PUBLIC_API_ENDPOINT` para definir de forma f√°cil o endere√ßo da API.

# Resultado

![Short GIF demo](/images/posts/docker_astro_asp/final_demo.gif)

Pronto, temos os nossos 3 servi√ßos se comunicando, o front-end, back-end e banco de dados. Tentei fazer da forma mais gen√©rica poss√≠vel, sem focar mais nas especificidades do meu projeto, pois quero mostrar uma vis√£o mais geral, para que voc√™ possa aplicar em qualquer projeto seu.

## Reposit√≥rio

Caso queira brincar com o Docker com um projeto real, clone o reposit√≥rio deste projeto:
[LuanRoger/DockerAstroAspApp](https://github.com/LuanRoger/DockerAstroAspApp)

## Obrigado

Obrigado se voc√™ leu at√© aqui,***¬†Peace‚úåÔ∏è***.